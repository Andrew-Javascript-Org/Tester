appName: microcks
ingresses: false


global:
  storageClass: ""
  imagePullSecrets: []
  imageRegistry: ""

externalDependencies:
  kafka:
    url: "kafka.example.com"
    port: "9092"
    protocol: "PLAINTEXT"
  mongodb:
    uri: "mognodb.example.com"
    port: "27017"
    # database: ""
    # uriParemeters: "?ssl=true"
    auth:
      username: ""
      password: ""
      secretRef:
        secret: ""
        usernameKey: ""
        passwordKey: ""
  keycloak:
    enabled: "true"
    url: "keycloak.example.com"
    realm: "microcks"
    auth:
      adminUsername: "microcks"
      admminPassword: "keycloak-microcks"
      secretRef:
        secret: keycloak
        usernameKey: "username"
        passwordKey: "password"

microcks:
  nameOverride: ""
  pod:
    labels: {}
    annotations: {}
    image:
      registry: "quay.io"
      repository: "quay.io/microcks/microcks"
      tag: "nightly"
      pullPolicy: IfNotPresent
    replicas: 1
    resources:
      requests:
        memory: 512Mi
        cpu: 200m
      limits:
        memory: 512Mi
        cpu: 500m
    logLevel: info
    # Enabling by adding yaml extra application configurations
    extraProperties:
      #server:
        #tomcat:
          #remoteip:
            #internal-proxies: 172.16.0.0/12
    env:
      - name: SERVICES_UPDATE_INTERVAL
        value: 0 0 0/2 * * *
      #- name: MAX_UPLOAD_FILE_SIZE
      #  value: 5MB
      #- name: CORS_REST_ALLOWED_ORIGINS
      #  value: my-site.acme.com
      #- name: CORS_REST_ALLOW_CREDENTIALS
      #  value: 'true'
  service:
    serviceType: LoadBalancer
    labels: {}
    annotations:
      external-dns.alpha.kubernetes.io/hostname: "microcks.example.com"
      service.beta.kubernetes.io/aws-load-balancer-name: "microcks"
      service.beta.kubernetes.io/aws-load-balancer-scheme: "internal"
      service.beta.kubernetes.io/aws-load-balancer-type: "external"
      service.beta.kubernetes.io/aws-load-balancer-nlb-target-type: "instance"
    port: 8080
    targetPort: 8080
  config:
    # This SSL toggle only control the reDirect URL protocol in realms.config file.
    ssl:
      enabled: false
    url: microcks.example.com
    #url: microcks-microcks.192.168.64.6.nip.io
    #ingressSecretRef: my-secret-for-microcks-ingress
    #ingressAnnotations:
      #cert-manager.io/issuer: my-cert-issuer
      #kubernetes.io/tls-acme: "true"
    #ingressClassName: nginx

    grpcEnableTLS: true
    #grpcSecretRef: my-secret-for-microcks-grpc
    #grpcIngressClassName: nginx
      #grpcIngressAnnotations:
    #myclass.ingress.kubernetes.io/backend-protocol: "GRPC"
    #myclass.ingress.kubernetes.io/ssl-passthrough: "true"

    generateCert: true
    # Enabling by adding yaml extra application configurations

    # Enabling/disabling mock invocation stats.
    mockInvocationStats: true

    # Custom secret for Microcks
    # It can be usec to deploy a keystore to add certificats to trust sso connection with   keycloak.
    # In this case: Use an existing secret with the provided keystore.
    # Don't forget to add java options like that if your secret is a keystore:
    # JAVA_OPTIONS: "-Djavax.net.ssl.trustStore=/deployments/config/custom/secret/KEYSTORE   -Djavax.net.ssl.trustStorePassword=XXXXX"
    #customSecretRef:
    #  secret: microcks-keystore
    #  key: cacerts
    postman-runtime:
      port: 8080
  realms:
    users:
      role:
        user:
          username: user
          password: microcks123
        manager:
          username: manager
          password: microcks123
        admin:
          username: admin
          password: microcks123

postman:
  pod:
    labels: {}
    annotations: {}
    image:
      registry: "quay.io"
      repository: "microcks/microcks-postman-runtime"
      tag: "latest"
      pullPolicy: IfNotPresent
    replicas: 1
    resources:
      requests:
        memory: 60Mi
        cpu: 50m
      limits:
        memory: 120Mi
        cpu: 100m
    logLevel: info
  service:
    type: ClusterIP
    labels: {}
    annotations: {}
    port: 8000
    targetPort: 3000

keycloak:
  ## ============================================================================
  ## For more customisation and specifics please check [ charts/keycloak/values.yaml ]
  ## Here are only some of the custimisable configurations for minimised setup.
  ## We do not recommend to deploy everything with an Omni-charts.
  ## Please considering deploying and maintaining these components independently.
  ## ============================================================================
  install: false
  ## ↓ Process the microcks-realm.json file via configMap !!! NOT VERIFIED !!!
  extraEnvVars:
    - name: KEYCLOAK_EXTRA_ARGS
      value: "-Dkeycloak.import=/tmp/import/microcks-realm.json"
  extraVolumeMounts:
    - name: import-realm
      mountPath: "/tmp/import"
      readOnly: true
  extraVolumes:
    - name: import-realm
      configMap:
        name: "microcks-keycloak-config"
        items:
        - key: "microcks-realms.json"
          path: "microcks-realms.json"
  ## ↑ Process the microcks-realm.json file via configMap !!! NOT VERIFIED !!!
  auth:
    adminUser: "user"
  # Unless you uncomment following line, admin password will be randomly generated.
  # Beware that in case of update, new value will be generated and
    adminPassword: "keycloak-microcks"
    existingSecret: ""
    passwordSecretKey: ""
    annotations: {}
  tls:
    enabled: false
    authGenerated: false
    existingSecret: ""
    usePem: false
    truststoreFilename: "keycloak.truststore.jks"
    keystoreFilename: "keycloak.keystore.jks"
    keystorePassword: ""
    truststorePassword: ""
    passwordsSecret: ""
  ## Keycloak resource requests and limits
  resourcesPreset: "small"
  resources:
    requests:
      cpu: 400m
      memory: 512Mi
    limits:
      #cpu: 500m
      memory: 512Mi
  externalDatabase:
    host: ""
    port: 5432
    user: bn_keycloak
    database: bitnami_keycloak
    password: ""
    existingSecret: ""
    existingSecretHostKey: ""
    existingSecretPortKey: ""
    existingSecretUserKey: ""
    existingSecretDatabaseKey: ""
    existingSecretPasswordKey: ""
    annotations: {}
  logging:
    output: default
    level: INFO
  serviceAccount:
    create: true
    name: "" # default will be "keycloak"

  postgresql:
    ## ============================================================================
    ## For more customisation and specifics please check [ charts/keycloak/charts/postgresql/values.yaml ]
    ## Here are only some of the custimisable configurations for minimised setup.
    ## We do not recommend to deploy everything with an Omni-charts.
    ## Please considering deploying and maintaining these components independently.
    ## ============================================================================
    enabled: true
    auth:
      postgresPassword: ""
      username: bn_keycloak
      password: ""
      database: bitnami_keycloak
      existingSecret: ""
    architecture: standalone
    persistence:
      enabled: true
      existingClaim: ""
      storageClass: ""
      size: 4Gi

mongodb:
  ## ============================================================================
  ## For more customisation and specifics please check [ charts/mongodb/values.yaml ]
  ## Here are only some of the custimisable configurations for minimised setup.
  ## We do not recommend to deploy everything with an Omni-charts.
  ## Please considering deploying and maintaining these components independently.
  ## ============================================================================
  install: false
  ## Standalone or replicaSet
  architecture: standalone
  useStatefulSet: false
  containerPorts:
    mongodb: 27017
  auth:
    enabled: true
    rootUser: root
    rootPassword: ""
    ## NOTE: When existingSecret is set the previous parameters are ignored.
    existingSecret: ""
  tls:
    enabled: false
    mTLS:
      ## IF TLS support is enabled, require clients to provide certificates
      enabled: true
    ## Generate a custom CA and self-signed certificates
    ##
    autoGenerated: true
  persistence:
    enabled: true
    existingClaim: ""
    ## Setting it to "keep" to avoid removing PVCs during a helm delete operation. Leaving it empty will delete PVCs after the chart deleted
    resourcePolicy: "keep"
    storageClass: ""
    size: 4Gi
  resources:
    ## Example:
    ## limits:
    ##    cpu: 100m
    ##    memory: 128Mi
    ##
    limits: {}
    ## Examples:
    ## requests:
    ##    cpu: 100m
    ##    memory: 128Mi
    ##
    requests: {}

kafka:
  ## ============================================================================
  ## For more customisation and specifics please check [ charts/kafka/values.yaml ]
  ## Here are only some of the custimisable configurations for minimised setup.
  ## We do not recommend to deploy everything with an Omni-charts.
  ## Please considering deploying and maintaining these components independently.
  ## ============================================================================
  install: false
  listeners:
    client:
      containerPort: 9092
      protocol: PLAINTEXT
      name: CLIENT
    controller:
      name: CONTROLLER
      containerPort: 9093
      protocol: PLAINTEXT
    external:
      containerPort: 9095
      protocol: PLAINTEXT
      name: EXTERNAL
  controller:
    replicaCount: 1
    resourcesPreset: "nano"
    ## resourcesPreset will be ignored if resources is given.
    resources: {}
    persistence:
      enabled: true
      existingClaim: ""
      storageClass: ""
      size: 4Gi
  externalAccess:
    ## Enable Kubernetes external cluster access to Kafka brokers.
    enabled: false
    ## External IPs auto-discovery configuration
    autoDiscovery:
      enabled: false
    ## Service settings
    controller:
      service:
        type: LoadBalancer
        ports:
          external: 9094
        annotations: {}

schema-registry:
  ## ============================================================================
  ## For more customisation and specifics please check [ charts/schema-registry/values.yaml ]
  ## Here are only some of the custimisable configurations for minimised setup.
  ## We do not recommend to deploy everything with an Omni-charts.
  ## Please considering deploying and maintaining these components independently.
  ## ============================================================================
  install: false
  externalKafka:
    ## The address and protocol should matches the Kafka instances configurations.
    brokers:
      - PLAINTEXT://kafka.9092
    listener:
      protocol: PLAINTEXT

features:
  async:
    enabled: false
    defaultBinding: KAFKA
    defaultFrequency: 10
    defaultAvroEncoding: RAW
    pod:
      labels: {}
      annotations: {}
      image:
        registry: "quay.io"
        repository: "microcks/microcks-async-minion"
        tag: "nightly"
        pullPolicy: IfNotPresent
      replicas: 1
      resources:
        requests: {}
        limits: {}
      logLevel: info
      env:
        #- name: OAUTH_CLIENT_ID
        #  value: <kafka-oauth-client-id>
        #- name: OAUTH_CLIENT_SECRET
        #  value: <kafka-oauth-client-secret>
        #- name: OAUTH_TOKEN_ENDPOINT_URI
        #  value: <kafka-oauth-endpoint-uri>
    service:
      type: ClusterIP
      labels: {}
      annotations: {}
      port: 8080
      targetPort: 8080

    configmap:
      labels: {}
      annotations: {}
      keycloak:
        uri: "keycloak.example.com"
        serviceAccount: "keycloak"

    kafka:
      install: false

    # Uncomment the mqtt.url and put a valid endpoint address below to enable MQTT support.
    mqtt:
      #url: artemis:1883
      username: microcks
      password: microcks

    # Uncomment the amqp.url and put a valid endpoint address below to enable AMQP support.
    amqp:
      #url: rabbitmq:5672
      username: microcks
      password: microcks

    # Uncomment the nats.url and put a valid endpoint address below to enable NATS support.
    nats:
      #url: nats:4222
      username: microcks
      password: microcks

    # Uncomment the googlepubsub.project and put a valid project id below to enable PubSub support.
    googlepubsub:
      #project: my-project
      # For authentication, we rely on a Google Service Account JSON file.
      # You have to setup a secret reference for retrieving this file from secret.
      serviceAccountSecretRef:
        secret: googlecloud-service-account
        fileKey: googlecloud-service-account.json

    # Uncomment the sqs.region and put a valid region below to enable Amazon SQS support.
    sqs:
      #region: eu-west-3
      # For authentication, we rely on either Environment Variables or an AWS Profile of type credentials (see https://docs.aws.amazon.com/sdk-for-php/v3/developer-guide/guide_credentials_profiles.html).
      # You can choose between 'env-variable' and 'profile'
      credentialsType: env-variable
      #credentialsType: profile
      # For 'env-variable', you may want to specify a Secret to get environment variables from.
      #credentialsSecretRef:
        #secret: aws-credentials
        #accessKeyIdKey: access_key_id
        #secretAccessKeyKey: secret_access_key
        #sessionTokenKey: session_token
      # For 'profile', you have to provide the profile name and setup a secret reference for retrieving this file from secret.
      credentialsProfile: microcks-sqs-admin
      #credentialsSecretRef:
        #secret: aws-credentials
        #fileKey: aws.profile

    # Uncomment the sns.region and put a valid region below to enable Amazon SNS support.
    sns:
      #region: eu-west-3
      # For authentication, we rely on either Environment Variables or an AWS Profile of type credentials (see https://docs.aws.amazon.com/sdk-for-php/v3/developer-guide/guide_credentials_profiles.html).
      # You can choose between 'env-variable' and 'profile'
      credentialsType: env-variable
      #credentialsType: profile
      # For 'env-variable', you may want to specify a Secret to get environment variables from.
      #credentialsSecretRef:
        #secret: aws-credentials
        #accessKeyIdKey: access_key_id
        #secretAccessKeyKey: secret_access_key
        #sessionTokenKey: session_token
      # For 'profile', you have to provide the profile name and setup a secret reference for retrieving this file from secret.
      credentialsProfile: microcks-sns-admin
      #credentialsSecretRef:
        #secret: aws-credentials
        #fileKey: aws.profile

    ws:
      #ingressSecretRef: my-secret-for-microcks-ws-ingress
      #ingressAnnotations:
        #cert-manager.io/issuer: my-ws-cert-issuer
        #kubernetes.io/tls-acme: "true"
      #ingressClassName: nginx
      generateCert: true

  repositoryFilter:
    enabled: false
    labelKey: app
    labelLabel: Application
    labelList: app,status

  repositoryTenancy:
    enabled: false
    artifactImportAllowedRoles: admin,manager,manager-any

  microcksHub:
    enabled: true
    allowedRoles: admin,manager,manager-any

  aiCopilot:
    enabled: false
    implementation: openai
    openai:
      apiKey: sk-my-openai-api-token
      timeout: 20
      #model: gpt-3.5-turbo
      #maxTokens: 2000

# common labels associated with all resources helm chart
commonLabels: {}