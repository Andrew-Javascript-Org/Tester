appName: microcks
ingresses: false


global:
  storageClass: ""
  imagePullSecrets: []
  imageRegistry: ""

microcks: # Waiting for verify
  # This SSL toggle only control the reDirect URL protocol in realms.config file.
  ssl:
    enabled: false
  url: microcks.example.com
  #url: microcks-microcks.192.168.64.6.nip.io
  #ingressSecretRef: my-secret-for-microcks-ingress
  #ingressAnnotations:
    #cert-manager.io/issuer: my-cert-issuer
    #kubernetes.io/tls-acme: "true"
  #ingressClassName: nginx

  grpcEnableTLS: true
  #grpcSecretRef: my-secret-for-microcks-grpc
  #grpcIngressClassName: nginx
    #grpcIngressAnnotations:
  #myclass.ingress.kubernetes.io/backend-protocol: "GRPC"
  #myclass.ingress.kubernetes.io/ssl-passthrough: "true"

  generateCert: true
  image: quay.io/microcks/microcks:nightly
  replicas: 1
  # Uncomment to change Microcks Service to a NodePort
  serviceType: ClusterIP
  serviceAnnotations: {}
    # external-dns.alpha.kubernetes.io/hostname: "microcks.example.com"
    # service.beta.kubernetes.io/aws-load-balancer-name: "microcks"
    # service.beta.kubernetes.io/aws-load-balancer-scheme: "internal"
    # service.beta.kubernetes.io/aws-load-balancer-type: "external"
    # service.beta.kubernetes.io/aws-load-balancer-nlb-target-type: "instance"

  resources:
    requests:
      cpu: 200m
      memory: 512Mi
    limits:
      cpu: 500m
      memory: 512Mi

  # Enabling by adding yaml extra application configurations
  extraProperties:
    #server:
      #tomcat:
        #remoteip:
          #internal-proxies: 172.16.0.0/12

  env:
    - name: SERVICES_UPDATE_INTERVAL
      value: 0 0 0/2 * * *
    #- name: MAX_UPLOAD_FILE_SIZE
    #  value: 5MB
    #- name: CORS_REST_ALLOWED_ORIGINS
    #  value: my-site.acme.com
    #- name: CORS_REST_ALLOW_CREDENTIALS
    #  value: 'true'

  #logLevel: TRACE | DEBUG | INFO | WARN
  logLevel: DEBUG

  # Enabling/disabling mock invocation stats.
  mockInvocationStats: true

  # Custom secret for Microcks
  # It can be usec to deploy a keystore to add certificats to trust sso connection with keycloak.
  # In this case: Use an existing secret with the provided keystore.
  # Don't forget to add java options like that if your secret is a keystore:
  # JAVA_OPTIONS: "-Djavax.net.ssl.trustStore=/deployments/config/custom/secret/KEYSTORE -Djavax.net.ssl.trustStorePassword=XXXXX"
  #customSecretRef:
  #  secret: microcks-keystore
  #  key: cacerts
  dependencies: # Waiting for verify
    mongodb:
      uri: "microcks-mognodb.example.com:27017"
      # database: ""
      # uriParemeters: "?ssl=true"
      auth:
        username: ""
        password: ""
        secretRef: ""
          secret: ""
          usernameKey: ""
          passwordKey: ""
    keycloak:
      enabled: "true"
      url: "microcks-keycloak.example.com"  # Bitnami chart using 80 as keycloak services
      realm: "microcks"
      serviceAccount: microcks-serviceaccount
      serviceAccountCredentials: ab54d329-e435-41ae-a900-ec6b3fe15c54
      auth:
        adminUsername: "hex"
        admminPassword: "keycloak-microcks"
        secretRef:
          secret: keycloak
          usernameKey: "username"
          passwordKey: "password"
  realms:
    users:
      role:
        user:
          username: user
          password: microcks123
        manager:
          username: manager
          password: microcks123
        admin:
          username: admin
          password: microcks123

postman: # WfV
  nameOverride: ""
  pod:
    labels: {}
    annotations: {}
    image:
      registry: "quay.io"
      repository: "microcks/microcks-postman-runtime"
      tag: "latest"
      pullPolicy: IfNotPresent
    replicas: 1
    resources:
      requests:
        memory: 60Mi
        cpu: 50m
      limits:
        memory: 120Mi
        cpu: 100m
    logLevel: info
  service:
    labels: {}
    annotations: {}
    port: 8000
    targetPort: 3000


keycloak: # WIP, but almost done, WfV
  # Use keycloack in this release
  enabled: true
  # Install keycloack in this release
  install: false
  extraEnvVars:
    - name: KEYCLOAK_EXTRA_ARGS
      value: "-Dkeycloak.import=/tmp/import/microcks-realm.json"
  extraVolumeMounts:
    - name: import-realm
      mountPath: "/tmp/import"
      readOnly: true
  extraVolumes:
    - name: import-realm
      configMap:
        name: "microcks-keycloak-config"
        items:
        - key: "microcks-realms.json"
          path: "microcks-realms.json"
  auth:
    adminUser: "user"
  # Unless you uncomment following line, admin password will be randomly generated.
  # Beware that in case of update, new value will be generated and
    adminPassword: "keycloak-microcks"
    existingSecret: ""
    passwordSecretKey: ""
    annotations: {}
  tls:
    enabled: false
    authGenerated: false
    existingSecret: ""
    usePem: false
    truststoreFilename: "keycloak.truststore.jks"
    keystoreFilename: "keycloak.keystore.jks"
    keystorePassword: ""
    truststorePassword: ""
    passwordsSecret: ""
  ## Keycloak resource requests and limits
  ## ref: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
  ## @param resourcesPreset Set container resources according to one common preset (allowed   values: none, nano, micro, small, medium, large, xlarge, 2xlarge). This is ignored if   resources is set (resources is recommended for production).
  ## More information: https://github.com/bitnami/charts/blob/main/bitnami/common/templates/  _resources.tpl#L15
  ##
  resourcesPreset: "small"
  resources:
    requests:
      cpu: 400m
      memory: 512Mi
    limits:
      #cpu: 500m
      memory: 512Mi
  ## @section Database parameters

  ## PostgreSQL chart configuration
  ## ref: https://github.com/bitnami/charts/blob/main/bitnami/postgresql/values.yaml
  ## @param postgresql.enabled Switch to enable or disable the PostgreSQL helm chart
  ## @param postgresql.auth.postgresPassword Password for the "postgres" admin user. Ignored if `auth.existingSecret` with key `postgres-password` is provided
  ## @param postgresql.auth.username Name for a custom user to create
  ## @param postgresql.auth.password Password for the custom user to create
  ## @param postgresql.auth.database Name for a custom database to create
  ## @param postgresql.auth.existingSecret Name of existing secret to use for PostgreSQL   credentials
  ## @param postgresql.architecture PostgreSQL architecture (`standalone` or `replication`)
  ##
  postgresql:
    enabled: true
    auth:
      postgresPassword: ""
      username: bn_keycloak
      password: ""
      database: bitnami_keycloak
      existingSecret: ""
    architecture: standalone
  ## External PostgreSQL configuration
  ## All of these values are only used when postgresql.enabled is set to false
  ## @param externalDatabase.host Database host
  ## @param externalDatabase.port Database port number
  ## @param externalDatabase.user Non-root username for Keycloak
  ## @param externalDatabase.password Password for the non-root username for Keycloak
  ## @param externalDatabase.database Keycloak database name
  ## @param externalDatabase.existingSecret Name of an existing secret resource containing the database credentials
  ## @param externalDatabase.existingSecretHostKey Name of an existing secret key containing the database host name
  ## @param externalDatabase.existingSecretPortKey Name of an existing secret key containing the database port
  ## @param externalDatabase.existingSecretUserKey Name of an existing secret key containing the database user
  ## @param externalDatabase.existingSecretDatabaseKey Name of an existing secret key   containing the database name
  ## @param externalDatabase.existingSecretPasswordKey Name of an existing secret key   containing the database credentials
  ## @param externalDatabase.annotations Additional custom annotations for external database secret object
  ##
  externalDatabase:
    host: ""
    port: 5432
    user: bn_keycloak
    database: bitnami_keycloak
    password: ""
    existingSecret: ""
    existingSecretHostKey: ""
    existingSecretPortKey: ""
    existingSecretUserKey: ""
    existingSecretDatabaseKey: ""
    existingSecretPasswordKey: ""
    annotations: {}
  logging:
    output: default
    level: INFO
    persistent: true
    volumeSize: 1Gi
    # Unless you uncomment following line and set class, persistent volume claim is created
    # with no storage class and relies on cluster default one.
    #storageClassName: my-awesome-class
    postgresImage: centos/postgresql-95-centos7:latest
    username: userP
    # Unless you uncomment following line, admin password will be randomly generated.
    # Beware that in case of update, new value will be generated and overwrite existing one.
    #password: 123
  serviceAccount:
    create: true

mongodb:  # WIP
  install: false
  uri: "microcks-mongodb.example.com:27017"
  #uriParameters: "?ssl=true"
  #database: sampledb
  image: library/mongo:4.4.29
  persistent: true
  volumeSize: 2Gi
  # Unless you uncomment following line and set class, persistent volume claim is created
  # with no storage class and relies on cluster default one.
  #storageClassName: my-awesome-class

  username: "microcks"
  # Unless you uncomment following line, admin password will be randomly generated.
  # Beware that in case of update, new value will be generated and overwrite existing one.
  password: "microcks"

  # Or you can uncomment secretRef block if username and password are provided through a Secret.
  #secretRef:
    #secret: mongodb
    #usernameKey: database-user
    #passwordKey: database-password

  #pvcAnnotations:
    #helm.sh/resource-policy: keep

  resources:
    requests:
      cpu: 250m
      memory: 512Mi
    limits:
      #cpu: 500m
      memory: 512Mi

features:
  async:
    enabled: false
    defaultBinding: KAFKA
    defaultFrequency: 10
    defaultAvroEncoding: RAW

    image: quay.io/microcks/microcks-async-minion:nightly

    env:
      #- name: OAUTH_CLIENT_ID
      #  value: <kafka-oauth-client-id>
      #- name: OAUTH_CLIENT_SECRET
      #  value: <kafka-oauth-client-secret>
      #- name: OAUTH_TOKEN_ENDPOINT_URI
      #  value: <kafka-oauth-endpoint-uri>

    kafka:
      install: true
      url: 192.168.99.100.nip.io
      #url: kafka-bootstrap:9092
      # Set this to your own class name if not using bare nginx
      ingressClassName: nginx
      persistent: false
      volumeSize: 2Gi
      resources:
        #requests:
          #cpu: 100m
          #memory: 256Mi
        limits:
          #cpu: 500m
          memory: 800Mi
      zkResources:
        #requests:
          #cpu: 100m
          #memory: 256Mi
        limits:
          #cpu: 500m
          memory: 800Mi
      schemaRegistry:
        #url: http://schema-registry.192.168.99.100.nip.io
        confluent: true
        username: microcks
        credentialsSource: USER_INFO

      # If you choose not to install a Kafka broker and reuse on pre-existing,
      # you may need to set some authentication parameters.
      authentication:
        # If not 'none', we support 'SSL' for mutual TLS and 'SASL_SSL' for SASL over TLS.
        type: none #SSL #SASL_SSL
        # For TLS transport, you'll always need a truststore to hold your cluster certificate.
        # You have to setup a truststore type and a secret reference for retrieving content and password.
        #truststoreType: PKCS12
        #truststoreSecretRef:
          #secret: kafka-cluster-ca-cert
          #storeKey: ca.p12
          #passwordKey: ca.password
        # For mutual TLS authentication, you'll also need a keystore to hold your user private key.
        # You have to setup a keystore type and a secret reference for retrieving content and password.
        keystoreType: PKCS12
        keystoreSecretRef:
          secret: mtls-user
          storeKey: user.p12
          passwordKey: user.password
        # For SASL authentication, you'll have to specify an additional authentication mechanism
        # as well as a JAAS configuration line with login module, username and password.
        #saslMechanism: SCRAM-SHA-512
        #saslJaasConfig: org.apache.kafka.common.security.scram.ScramLoginModule required username="scram-user" password="tDtDCT3pYKE5";
        # or an OAuth configuration (you'll need here to extend the async-minion image with your handler class implementation)
        #saslMechanism: OAUTHBEARER
        #saslJaasConfig: org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required;
        #saslLoginCallbackHandlerClass: io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler

    # Uncomment the mqtt.url and put a valid endpoint address below to enable MQTT support.
    mqtt:
      #url: artemis:1883
      username: microcks
      password: microcks

    # Uncomment the amqp.url and put a valid endpoint address below to enable AMQP support.
    amqp:
      #url: rabbitmq:5672
      username: microcks
      password: microcks

    # Uncomment the nats.url and put a valid endpoint address below to enable NATS support.
    nats:
      #url: nats:4222
      username: microcks
      password: microcks

    # Uncomment the googlepubsub.project and put a valid project id below to enable PubSub support.
    googlepubsub:
      #project: my-project
      # For authentication, we rely on a Google Service Account JSON file.
      # You have to setup a secret reference for retrieving this file from secret.
      serviceAccountSecretRef:
        secret: googlecloud-service-account
        fileKey: googlecloud-service-account.json

    # Uncomment the sqs.region and put a valid region below to enable Amazon SQS support.
    sqs:
      #region: eu-west-3
      # For authentication, we rely on either Environment Variables or an AWS Profile of type credentials (see https://docs.aws.amazon.com/sdk-for-php/v3/developer-guide/guide_credentials_profiles.html).
      # You can choose between 'env-variable' and 'profile'
      credentialsType: env-variable
      #credentialsType: profile
      # For 'env-variable', you may want to specify a Secret to get environment variables from.
      #credentialsSecretRef:
        #secret: aws-credentials
        #accessKeyIdKey: access_key_id
        #secretAccessKeyKey: secret_access_key
        #sessionTokenKey: session_token
      # For 'profile', you have to provide the profile name and setup a secret reference for retrieving this file from secret.
      credentialsProfile: microcks-sqs-admin
      #credentialsSecretRef:
        #secret: aws-credentials
        #fileKey: aws.profile

    # Uncomment the sns.region and put a valid region below to enable Amazon SNS support.
    sns:
      #region: eu-west-3
      # For authentication, we rely on either Environment Variables or an AWS Profile of type credentials (see https://docs.aws.amazon.com/sdk-for-php/v3/developer-guide/guide_credentials_profiles.html).
      # You can choose between 'env-variable' and 'profile'
      credentialsType: env-variable
      #credentialsType: profile
      # For 'env-variable', you may want to specify a Secret to get environment variables from.
      #credentialsSecretRef:
        #secret: aws-credentials
        #accessKeyIdKey: access_key_id
        #secretAccessKeyKey: secret_access_key
        #sessionTokenKey: session_token
      # For 'profile', you have to provide the profile name and setup a secret reference for retrieving this file from secret.
      credentialsProfile: microcks-sns-admin
      #credentialsSecretRef:
        #secret: aws-credentials
        #fileKey: aws.profile

    ws:
      #ingressSecretRef: my-secret-for-microcks-ws-ingress
      #ingressAnnotations:
        #cert-manager.io/issuer: my-ws-cert-issuer
        #kubernetes.io/tls-acme: "true"
      #ingressClassName: nginx
      generateCert: true

  repositoryFilter:
    enabled: false
    labelKey: app
    labelLabel: Application
    labelList: app,status

  repositoryTenancy:
    enabled: false
    artifactImportAllowedRoles: admin,manager,manager-any

  microcksHub:
    enabled: true
    allowedRoles: admin,manager,manager-any

  aiCopilot:
    enabled: false
    implementation: openai
    openai:
      apiKey: sk-my-openai-api-token
      timeout: 20
      #model: gpt-3.5-turbo
      #maxTokens: 2000

# common labels associated with all resources helm chart
commonLabels: {}

# common annotations associated with all resource of this helm chart
commonAnnotations: {}
